import time
import logging
import pytz

from datetime import datetime

from nameko.events import event_handler
from nameko.dependency_providers import Config
from nameko.rpc import RpcProxy
from nameko.rpc import rpc
from nameko.events import EventDispatcher

from smart_heating.exceptions import UnableToControlError
from smart_heating.exceptions import IndoorDataError
from smart_heating.exceptions import DeltaTimeError

SETTLING_TIME = 21600

HEATING_SEASON_BEGIN_MONTH_DAY = '10-01'   # t_start
HEATING_SEASON_END_MONTH_DAY = '04-01'     # t_end

# Initial ITP temperature when no previous temperature exists
#
INITIAL_ITP_TEMP = 22.0


class SmartHeating:
    name = "smart_heating"
    timeseries = RpcProxy("timeseries")
    population = RpcProxy("population")
    dispatcher = EventDispatcher()
    config = Config()

    @event_handler("stream-analytics", "validated_subplant_data")
    def handle_new_reading(self, payload):
        """ Listens for new readings in the uc sensor pipeline and initiates a
        new smart heating control.

        Dispatches a new control when finsihed and updates the device shadow
        state. When the state is updated a message is published at a MQTT topic
        which triggers a new steering in the gateway connected to the
        corresponding measurepoint id.

        Parameters
        ----------
        payload : dict
            The uc reading data.
        """

        m_id, outdoor_temp = _validate_payload(payload, self.config)
        self.init_control(m_id, payload['ts'], outdoor_temp)

        if isinstance(self.control, PIDControl):
            if self.control.ready and (
                    self.control.active
                    or self.control.control_type != 'heating'
            ):
                logging.debug("{0}: Running PID control".format(m_id))

                self.init_control_history()
                new_control = self.init_pid()

                logging.debug("{0}: Dispatching control".format(m_id))

                self.dispatcher("new_outdoor_temp_control", new_control)
            else:
                logging.info(
                    "{0}: Smart heating cancelled. Active: {1}. Ready: {2}".format(
                        self.control.m_id,
                        self.control.active,
                        self.control.ready
                    )
                )
        else:
            logging.debug('{0}: Running Simple control'.format(m_id))
            new_control = self.control.serialize()

            logging.debug("{0}: Dispatching control".format(m_id))
            self.dispatcher("new_outdoor_temp_control", new_control)

    def init_control(self, m_id, ts, outdoor_temp):
        logging.debug('init control')
        params = Params(self.population.get_sh_params(m_id, ts))

        if not params.has_sensors and params.control_type != 'heating':
            self.control = SimpleControl(m_id, ts, outdoor_temp, params)
        else:
            self.control = PIDControl(m_id, ts, outdoor_temp, params)

    def init_control_history(self):
        logging.debug("{0}: Fetching history".format(self.control.m_id))

        history = self.timeseries.get_heat_control_history(
            self.control.m_id,
            timestamp='{}s'.format(self.control.ts),
        )

        self.control.history = history

    def init_pid(self):
        logging.debug("{0}: Init PID...".format(self.control.m_id))
        self.control.set_prev_control()

        logging.debug("{0}: ...dt".format(self.control.m_id))
        self.control.set_dt()

        logging.debug("{0}: ...getting latest temp, bounds {1} and time frame {2}".format(
            self.control.m_id,
            self.control.indoor_temp.bounds,
            self.control.indoor_temp.time_frame,
        ))

        latest_t = self.timeseries.get_latest_mean_t_for_mid(
            self.control.m_id,
            self.control.indoor_temp.bounds,
            self.control.indoor_temp.time_frame,
            timestamp='{}s'.format(self.control.ts),
        )

        logging.debug("{0}: ...setting latest temp to {1}".format(
            self.control.m_id,
            latest_t,
        ))
        self.control.indoor_temp.set_latest(latest_t)

        # START OF ITP
        logging.debug("{0}: ...ITP params dmax({1},{2})".format(
            self.control.m_id,
            self.control.indoor_filtered_temp.itp_dmax_lower,
            self.control.indoor_filtered_temp.itp_dmax_higher,
        ))
        try:
            self.control.set_prev_itp_temp()

            last_indoor_temps = \
              self.timeseries.get_last_indoor_temps(self.control.m_id,
                                                  history="5m")
            latest_itp_t = \
              self.control.indoor_filtered_temp.get_temp(
                current_temps=last_indoor_temps)

            logging.debug("{0}: indoor temps mean {1} weighted {2}".format(
                self.control.m_id,
                latest_t,
                latest_itp_t,
            ))
        except Exception as e:
            logging.info(e)

        # END OF ITP

        logging.debug("{0}: ...setting delta".format(self.control.m_id))
        self.control.indoor_temp.set_delta(self.control.history)

        logging.debug("{0}: Done setting parameters, running control!".format(
            self.control.m_id)
        )
        self.control.run()

        logging.debug("{0}: PID complete, serializing and returning result.".format(
            self.control.m_id)
        )
        return self.control.serialize()

    @rpc
    def get_pid_constants(self, params):
        constants = PIDConstants(
            theta_p=int(params['delay_time']),
            mc_p=int(params['mc_p']),
            kp=params['kp_override'],
            ki=params['ki_override'],
            kd=params['kd_override'],
            ua=int(params['ua']),
        )

        return {
            'kp': constants.kp,
            'ki': constants.ki,
            'kd': constants.kd,
        }


class IndoorTemp:
    def __init__(self, time_frame, upper_dev, lower_dev):
        self.time_frame = time_frame
        self.upper_dev = upper_dev
        self.lower_dev = lower_dev

        self.delta = None
        self.latest = None

    def set_latest(self, latest):
        if not latest:
            raise IndoorDataError("No indoor data")

        self.latest = float(latest['mean'])

    def set_delta(self, history=None):
        prev_temp = history[-1]['it'] if history else self.latest
        self.delta = self.latest - prev_temp

    @property
    def bounds(self):
        return (self.lower_dev, self.upper_dev)


class IndoorFilteredTemp:
    def __init__(self, itp_dmax_higher, itp_dmax_lower, itp_filter_constant):
        self.itp_dmax_higher = itp_dmax_higher
        self.itp_dmax_lower = itp_dmax_lower
        self.itp_filter_constant = itp_filter_constant

        self.trep = None
        self.latest = None

    def set_trep(self, trep):
        self.trep = trep

    def set_latest(self, latest):
        self.latest = latest

    def _compute_weight(self, temp, lower_window_bound, upper_window_bound):
        # Eq. 5 & 6, chap 6.1, VS 2018-11-12
        #
        if lower_window_bound <= temp <= upper_window_bound:
            di = abs(temp - self.trep)
        elif temp > upper_window_bound:
            di = self.itp_dmax_higher
        else:
            di = self.itp_dmax_lower

        if temp > self.trep:
            return 1 - (di / self.itp_dmax_higher)
        else:
            return 1 - (di / self.itp_dmax_lower)

    def _weighted_triangle_window(self, current_temps):
        """Weighted triangle window function"""
        upper_window_bound = self.trep + self.itp_dmax_higher
        lower_window_bound = self.trep - self.itp_dmax_lower

        weights = [self._compute_weight(t,
                                        lower_window_bound,
                                        upper_window_bound)
                   for t in current_temps]

        # Eq. 7, chap 6.1, VS 2018-11-12
        # sum(for all i):  wi Ã— Ti
        # ----------------------
        # sum(for all i): wi
        weights_sum = sum(weights)

        weight_temp_est_prods = sum([w * t for (w, t)
                                     in zip(weights, current_temps)])

        # Figure 11, chap 6.1, VS 2018-11-12
        return self.itp_filter_constant *  weight_temp_est_prods / weights_sum + (1 - self.itp_filter_constant ) * self.trep

    def get_temp(self, current_temps):
        self.latest = self._weighted_triangle_window(current_temps)
        return self.latest


class PIDConstants:
    def __init__(self, theta_p, mc_p, ua, kp=None, ki=None, kd=None, alpha=None):
        """ Setting PID constants. Uses kp, ki, kd overrides values if provided
        otherwise it calculates them based on tau calculations.
        """
        logging.debug('Creating constants')
        self.theta_p = theta_p
        self.time_constant = mc_p / ua

        self.tau_c = self.calc_tau_c()
        self.tau_i = self.calc_tau_i()
        self.tau_d = self.calc_tau_d()

        self.kp = round(kp, 6) if kp is not None else self.calc_kp()
        self.ki = round(ki, 6) if ki is not None else self.kp / self.tau_i
        self.kd = round(kd, 6) if kd is not None else self.kp * self.tau_d

        logging.debug('Setting alpha {}'.format(alpha))
        self.alpha = alpha
        logging.debug('Done setting constants.')

    def calc_tau_c(self):
        return max(0.1 * self.time_constant, 0.8 * self.theta_p)

    def calc_tau_i(self):
        return self.time_constant + 0.5 * self.theta_p

    def calc_tau_d(self):
        return self.time_constant * self.theta_p / (2 * self.time_constant + self.theta_p)

    def calc_kp(self):
        return (self.time_constant + 0.5 * self.theta_p) / (self.tau_c + 0.5 * self.theta_p)

    def set_alpha(self, dt):
        if self.alpha:
            return

        a = self.calc_alpha()
        self.alpha = min(max((dt / a), 0), 1)

    def calc_alpha(self):
        n = self.tau_c * (self.time_constant + 0.5 * self.theta_p)
        d = self.time_constant * (self.tau_c + self.theta_p)
        return (n / d) * self.tau_d


class Params(object):
    def __init__(self, d):
        self.__dict__ = d


class PIDControl:
    def __init__(self, m_id, ts, outdoor_temp, params):
        self.m_id = m_id
        self.ts = int(ts)
        self.outdoor_temp = float(outdoor_temp)

        self.active = params.active
        self.dry_run = params.dry_run
        self.ready = params.ready
        self.flagged_for_reset = params.flagged_for_reset
        self.control_type = params.control_type
        self.has_sensors = params.has_sensors

        self.apply_alpha_filter = params.alpha_filter

        self.set_value = float(params.set_value)
        self.set_value_delta = float(getattr(params, 'set_value_delta', 0.0))
        self.repr_set_value = self.set_value - self.set_value_delta
        self.t_offset_optimization = params.t_offset_optimization
        self.allowed_error = float(params.allowed_error)
        self.turning_temp = float(params.pow_sig_tt)
        self.funnel = params.control_funnel

        logging.debug(params.__dict__)

        self.constants = PIDConstants(
            theta_p=int(params.delay_time),
            mc_p=int(params.mc_p),
            ua=params.ua,
            kp=params.kp_override,
            ki=params.ki_override,
            kd=params.kd_override,
            alpha=params.alpha_override,
        )

        self.indoor_temp = IndoorTemp(
            params.indoor_temp_time_frame,
            params.indoor_temp_upper_dev,
            params.indoor_temp_lower_dev
        )

        self.indoor_filtered_temp = IndoorFilteredTemp(
            params.itp_dmax_higher,
            params.itp_dmax_lower,
            params.itp_filter_constant,
        )

        self.upper_offset_bound = params.upper_offset_bound
        self.lower_offset_bound = params.lower_offset_bound

        self.reset = False
        self.history = None
        self.prev_control = None
        self.t_bias = None
        self.e = None
        self.dt = None
        self.sum_e = None
        self.pre_alpha_offset = None
        self.period = None
        self.t_offset = None
        self.steady_duration = None
        self.state = 0

    def run(self):
        logging.debug('setting e')
        self.set_e()

        logging.debug('updating steady duration')
        self.update_steady_duration()

        logging.debug('updating state')
        self.update_state()

        logging.debug('setting period')
        self.set_period()

        logging.debug('checking for reset')
        self.check_for_reset()

        logging.debug('setting sum e')
        self.set_sum_e()

        logging.debug('setting t bias')
        self.set_t_bias()

        logging.debug('setting t offset')
        self.set_t_offset()

    def parse_month_day(self, month_day_string):
        month, day = month_day_string.split("-")

        return (int(month), int(day))

    def timestamp_to_month_day(self, timestamp):
        tz = pytz.timezone("Europe/Stockholm")
        current_datetime = datetime.fromtimestamp(timestamp, tz)
        return (current_datetime.month, current_datetime.day)

    def month_day_less_than(self, month_day_a, month_day_b):
        """Checks if the (month, day) tuple month_day_a is earlier
        than (month, day) tuple month_day_b"""
        return month_day_a[0]*100 + month_day_a[1] < month_day_b[0]*100 + month_day_b[1]

    def month_day_greater_than(self, month_day_a, month_day_b):
        """Checks if the (month, day) tuple month_day_a is later
        than (month, day) tuple month_day_b"""

        return month_day_a[0]*100 + month_day_a[1] > month_day_b[0]*100 + month_day_b[1]

    def is_heating_season(self, current_timestamp):
        """Checks if we are currently in the heating season."""
        heating_season_begin = self.parse_month_day(HEATING_SEASON_BEGIN_MONTH_DAY)
        heating_season_end = self.parse_month_day(HEATING_SEASON_END_MONTH_DAY)

        current_month_day = self.timestamp_to_month_day(current_timestamp)

        return any((self.month_day_less_than(current_month_day, heating_season_end),
                    self.month_day_greater_than(current_month_day, heating_season_begin)))

    @property
    def t_active(self):
        t_active = float(self.outdoor_temp) - float(self.t_offset)

        max_t_active = max(self.turning_temp, self.outdoor_temp)
        if self.is_heating_season(self.ts) and t_active > max_t_active:
            t_active = max_t_active

        return t_active

    def set_prev_control(self):
        logging.debug('Setting prev control with history: {0}'.format(
            self.history
        ))

        if self.history:
            self.prev_control = self.history[-1]
            self.state = self.prev_control['state']
        else:
            self.apply_alpha_filter = False
            self.prev_control = {
                'time': self.ts - 360,
                'state': 0,
                't_bias': 0,
                'steady_duration': 0,
                't_offset': 0,
                'set_value': self.set_value,
            }

    def set_prev_itp_temp(self):
        if self.history and 'itp_it' in self.history[-1]:
            hist_itp = self.history[-1]['itp_it']
            logging.debug("{0}: itp setting latest temp to {1}".
                          format(self.m_id, hist_itp))
        else:
            # No previous ITP temp: use set_value
            hist_itp = self.repr_set_value
            logging.debug("{0}: itp no previous temp, init to set_value {1}".
                          format(self.m_id, hist_itp))

        self.indoor_filtered_temp.set_trep(hist_itp)

    def set_t_bias(self):
        if self.reset:
            self.t_bias = self.constants.ki * self.historical_sum_e
        else:
            self.t_bias = self.prev_control['t_bias']

    def set_e(self):
        self.e = self.calc_e()

    def set_dt(self):
        self.dt = self.calc_dt()

    def set_period(self):
        self.period = self.calc_period()

    def set_sum_e(self):
        self.sum_e = self.calc_sum_e()

    def set_t_offset(self):
        self.t_offset = self.calc_t_offset()

    def calc_dt(self):
        dt = self.ts - self.prev_control['time']

        if dt <= 0:
            raise DeltaTimeError("Negative or zero delta time.")

        return dt

    def calc_e(self):
        return self.set_value - self.indoor_temp.latest

    @property
    def historical_sum_e(self):
        if self.history:
            # return sum(h['e'] * h['dt'] for h in self.history)
            return self.prev_control['sum_e']
        else:
            return 0

    def calc_sum_e(self):
        sum_e = self.e * self.dt

        if self.history and not self.reset:
            sum_e = sum_e + self.historical_sum_e

        max_sum_e = self.upper_offset_bound/self.constants.ki
        min_sum_e = self.lower_offset_bound/self.constants.ki
        return max(min(sum_e, max_sum_e), min_sum_e)

    def calc_period(self):
        if 'period' in self.prev_control:
            period = self.prev_control['period'] + self.dt
        else:
            period = self.dt

        return min(period, 86400)

    def apply_offset_bounds(self, offset):
        return max(
            min(offset, self.upper_offset_bound),
            self.lower_offset_bound
        )

    def calc_t_offset(self):

        if not self.history:
            # actually, if there is no history the only summand which cannot be done is the derivative term since dt=0
            t_offset = (self.constants.kp * self.e +
                        self.constants.ki * self.sum_e)
        else:
            t_offset = (self.constants.kp * self.e +
                        self.constants.ki * self.sum_e -
                        self.constants.kd * self.indoor_temp.delta / self.dt)

        self.pre_alpha_offset = t_offset

        if self.apply_alpha_filter and self.history:
            self.constants.set_alpha(self.dt)
            p = self.prev_control['t_offset']
            t_offset = p + self.constants.alpha * (t_offset - p)

        return self.apply_offset_bounds(t_offset)

    def update_steady_duration(self):
        if (self.state == 1 and abs(
                self.e) <= self.allowed_error) or self.state == 0:
            self.steady_duration = self.prev_control[
                                       'steady_duration'] + self.dt
        else:
            self.steady_duration = 0

    def update_state(self):
        current_state = self.prev_control['state']

        settled = (
            (current_state == 0 and abs(self.e) <= self.allowed_error) or
            (current_state == 1 and self.is_steady)
        )

        self.state = 0 if settled else 1

    @property
    def is_steady(self):
        return self.steady_duration >= SETTLING_TIME

    @property
    def has_changed_state(self):
        return self.state == 0 and self.prev_control['state'] == 1

    @property
    def has_changed_set_value(self):
        return self.set_value != self.prev_control['set_value']

    def check_for_reset(self):
        if (self.has_changed_set_value or self.flagged_for_reset):
            self.reset = True
            self.period = 0

    def serialize(self):
        return {
            "control_type": self.control_type,
            "m_id": self.m_id,
            "t_active": self.t_active,
            "t_offset": float(self.t_offset),
            "set_value": float(self.set_value),
            "repr_set_value": self.repr_set_value,
            "e": self.e,
            "it": self.indoor_temp.latest,
            "itp_it": self.indoor_filtered_temp.latest,
            "time": int(self.ts),
            "end": int(self.ts) + 3600,
            "t_bias": self.t_bias,
            "period": self.period,
            "state": self.state,
            "dt": self.dt,
            "steady_duration": self.steady_duration,
            "dry_run": self.dry_run,
            "sum_e": self.sum_e,
            "pre_alpha_offset": self.pre_alpha_offset,
            "alpha_constant": self.constants.alpha if self.constants.alpha else -1,
            "funnel": self.funnel,
            "t_offset_optimization": self.t_offset_optimization,
        }


class SimpleControl:
    def __init__(self, m_id, ts, outdoor_temp, params):
        self.m_id = m_id
        self.ts = int(ts)
        self.outdoor_temp = float(outdoor_temp)

        self.dry_run = params.dry_run
        self.control_type = params.control_type
        self.has_sensors = params.has_sensors
        self.set_value_delta = params.set_value_delta
        self.funnel = params.control_funnel

    @property
    def t_active(self):
        return self.outdoor_temp - self.set_value_delta

    def serialize(self):
        return {
            "control_type": self.control_type,
            "m_id": self.m_id,
            "t_active": self.t_active,
            "time": self.ts,
            "dry_run": self.dry_run,
            "end": self.ts + 3600,
            "funnel": self.funnel
        }


def _validate_payload(payload, config):
    outdoor_temp = None
    m_id = payload['m_id']
    ts = payload['ts']
    now = int(time.time())
    max_reading_age = config.get('MAX_READING_AGE', 300)

    try:
        for e in payload['readings']:
            if e['name'].lower() == 'vs01_gt3u':
                outdoor_temp = float(e['value'])
    except KeyError:
        raise UnableToControlError('{}: No outdoor temp key.'.format(m_id))

    if not outdoor_temp:
        raise UnableToControlError('{}: No outdoor temp value.'.format(m_id))

    if ts < now - max_reading_age:
        raise UnableToControlError('{}: Reading to old.'.format(m_id))

    return m_id, outdoor_temp
